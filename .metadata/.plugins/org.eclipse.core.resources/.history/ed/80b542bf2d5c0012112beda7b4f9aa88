/*
 * 
 * 		Shamrock Lane relies heavily on the Rajawali framework which can be found here:
 * 
 * 		https://github.com/MasDennis/Rajawali
 * 		
 * 		Rajawali --
 * 		Copyright 2011 Dennis Ippel
 * 		Licensed under the Apache License, Version 2.0 (the "License");
 * 		you may not use this file except in compliance with the License.
 * 		You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 *     
 *      Unless required by applicable law or agreed to in writing, software
 *      distributed under the License is distributed on an "AS IS" BASIS,
 *      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *      See the License for the specific language governing permissions and
 *      limitations under the License.
 *
 */

package com.evvid.wallpapers.shamrocklane;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import com.evvid.wallpapers.shamrocklane.R;

import rajawali.BaseObject3D;
import rajawali.renderer.RajawaliRenderer;
import android.content.Context;
import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.opengl.GLES20;
import android.preference.PreferenceManager;
import android.view.MotionEvent;

import rajawali.materials.SimpleMaterial;
//Serializer//
import rajawali.parser.ObjParser;
import rajawali.util.MeshExporter;
import rajawali.util.MeshExporter.ExportType;


public class WallpaperRenderer extends RajawaliRenderer{
			
	private OnSharedPreferenceChangeListener mListener;

	private float xpos, ypos;
	
	private BaseObject3D castle, ground, path, walls, arch, stump, stumpdecal, waterfall, pot, gold, rbow1, rbow2, tree, door;
	
	private Bitmap castleTex, groundTex, pathTex, wallStumpTex, potBowTex, waterfallrockTex, doorGateArchTex, treeTex;
	
	public WallpaperRenderer(Context context) {
		super(context);
		setFrameRate(60);
		setBackgroundColor(0x2b426e);
    }
		
	public void initScene() {
			
		setOnPreferenceChange();
		setPrefsToLocal();
		
		lightsCam();
		loadTextures();
		loadObjects();
		
		addObjects();
	}
	
	private void lightsCam(){
		mCamera.setFarPlane(1000);
		mCamera.setPosition(0, 0, 20);
		mCamera.setLookAt(-2, 1, 5);
	}
	
	private void loadTextures(){
		castleTex = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.castle);
		groundTex = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.grass2);
		pathTex = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.path);
		wallStumpTex = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.wall_stump);
		potBowTex = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.pot);
		waterfallrockTex = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.waterfallrock_tex);
		doorGateArchTex = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.door_gate_arch);
		treeTex = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.btree);
	}
	
	private void loadObjects(){		
		try {	
			//SCENERY//
			SimpleMaterial castleMat = new SimpleMaterial();
			SimpleMaterial groundMat = new SimpleMaterial();
			SimpleMaterial pathMat = new SimpleMaterial();
			SimpleMaterial wallStumpMat = new SimpleMaterial();
			SimpleMaterial potBowMat = new SimpleMaterial();
			SimpleMaterial waterfallrockMat = new SimpleMaterial();
			SimpleMaterial doorGateArchMat = new SimpleMaterial();
			SimpleMaterial treeMat = new SimpleMaterial();

			castleMat.addTexture(mTextureManager.addTexture(castleTex));
			groundMat.addTexture(mTextureManager.addTexture(groundTex));
			pathMat.addTexture(mTextureManager.addTexture(pathTex));
			wallStumpMat.addTexture(mTextureManager.addTexture(wallStumpTex));
			potBowMat.addTexture(mTextureManager.addTexture(potBowTex));
			waterfallrockMat.addTexture(mTextureManager.addTexture(waterfallrockTex));
			doorGateArchMat.addTexture(mTextureManager.addTexture(doorGateArchTex));
			treeMat.addTexture(mTextureManager.addTexture(treeTex));
			
			ObjParser objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.castle_obj);
			objParser.parse();
			castle = objParser.getParsedObject();
			castle.setMaterial(castleMat);

			objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.ground_obj);
			objParser.parse();
			ground = objParser.getParsedObject();
			ground.setMaterial(groundMat);

			objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.path_obj);
			objParser.parse();
			path = objParser.getParsedObject();
			path.setMaterial(pathMat);
			path.setBlendingEnabled(true);
			path.setBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);
			path.setY(.1f);

			objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.stumpdecal_obj);
			objParser.parse();
			stumpdecal = objParser.getParsedObject();
			stumpdecal.setMaterial(pathMat);
			stumpdecal.setBlendingEnabled(true);
			stumpdecal.setBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);
			stumpdecal.setY(.1f);
			
			objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.walls_obj);
			objParser.parse();
			walls = objParser.getParsedObject();
			walls.setMaterial(wallStumpMat);
			walls.setDoubleSided(true);

			objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.arch_obj);
			objParser.parse();
			arch = objParser.getParsedObject();
			arch.setMaterial(doorGateArchMat);
			
			objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.stump_obj);
			objParser.parse();
			stump = objParser.getParsedObject();
			stump.setMaterial(wallStumpMat);

			objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.waterfall_obj);
			objParser.parse();
			waterfall = objParser.getParsedObject();
			waterfall.setMaterial(waterfallrockMat);

			objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.pot_obj);
			objParser.parse();
			pot = objParser.getParsedObject();
			pot.setMaterial(potBowMat);
			pot.setDoubleSided(true);

			objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.gold_obj);
			objParser.parse();
			gold = objParser.getParsedObject();
			gold.setMaterial(waterfallrockMat);

			objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.rbow1_obj);
			objParser.parse();
			rbow1 = objParser.getParsedObject();
			rbow1.setMaterial(potBowMat);
			rbow1.setDoubleSided(true);
			rbow1.setBlendingEnabled(true);
			rbow1.setBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_COLOR);

			objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.rbow2_obj);
			objParser.parse();
			rbow2 = objParser.getParsedObject();
			rbow2.setMaterial(potBowMat);
			rbow2.setDoubleSided(true);
			rbow2.setBlendingEnabled(true);
			rbow2.setBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_COLOR);

			objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.tree_obj);
			objParser.parse();
			tree = objParser.getParsedObject();
			tree.setMaterial(treeMat);
			
			objParser = new ObjParser(mContext.getResources(), mTextureManager, R.raw.door_obj);
			objParser.parse();
			door = objParser.getParsedObject();
			door.setMaterial(doorGateArchMat);

		} catch (Exception e){
			e.printStackTrace();
		}	
	}
	

	
	private void addObjects(){		
		addChild(castle);			
		addChild(rbow1);			
		addChild(ground);			
		addChild(path);			
		addChild(walls);			
		addChild(arch);			
		addChild(stumpdecal);			
		addChild(stump);			
		addChild(tree);			
		addChild(door);			
		addChild(waterfall);
		addChild(pot);
		addChild(rbow2);			
	}
	
	private void setOnPreferenceChange(){
	
	}
	
	private void setPrefsToLocal(){
	}
		
	@Override
	public void onSurfaceCreated(GL10 gl, EGLConfig config) {
		try{
			super.onSurfaceCreated(gl, config);
		}catch (Exception e){
			e.printStackTrace();
			initScene();
		}
        PreferenceManager.setDefaultValues(mContext, R.xml.settings, true);
		preferences.registerOnSharedPreferenceChangeListener(mListener);
	}
	
	@Override
	public void onSurfaceChanged(GL10 gl, int width, int height) { // Check for screen rotation
		super.onSurfaceChanged(gl, width, height);
	}
	
	@Override
	public void onSurfaceDestroyed() {
		clearChildren();
		try{
			super.onSurfaceDestroyed();
		}catch (Exception e){
			e.printStackTrace();
		}		
		preferences.unregisterOnSharedPreferenceChangeListener(mListener);
		recycleTextures();	
	}
	
	private void recycleTextures(){
		try{
			System.gc();
		} catch (Exception e){
			e.printStackTrace();
		}
	}

	@Override
	public void onDrawFrame(GL10 glUnused) {
		try{
			super.onDrawFrame(glUnused);
		}catch (Exception e) {
			e.printStackTrace();
		}
	}	

	private void cameraTrack(float xOffset, float yOffset, int pointerCount) {
        xOffset = xOffset/10f;
		yOffset = yOffset/10f;
		if (mCamera.getY() < 0) mCamera.setY(0);
		if (mCamera.getY() > 75) mCamera.setY(75);
  	    if (mCamera.getY() > 15 || (mCamera.getY() + yOffset) > 0) mCamera.setY((mCamera.getY() + yOffset));

		if (mCamera.getZ() < -200) mCamera.setZ(-200);
		if (mCamera.getZ() > 200) mCamera.setZ(200);
   	    if (pointerCount == 2) mCamera.setX((mCamera.getX() + xOffset));
   	    else mCamera.setZ((mCamera.getZ() + xOffset));
	}


		

	@Override //This method moves the camera using direct touch events. Tracking a flick and turning it into a procedural animation for smoothing
	public void onTouchEvent(MotionEvent me) {
	       if (me.getAction() == MotionEvent.ACTION_DOWN) {
	           xpos = me.getX();
	           ypos = me.getY();
	    		   		
	       }
	       if (me.getAction() == MotionEvent.ACTION_MOVE) {
	           float xd = xpos - me.getX(0);
	           float yd = ypos - me.getY(0);
	           int pointerCount = me.getPointerCount();
	           cameraTrack(xd, yd, pointerCount);
	    	   xpos = me.getX(0);
	           ypos = me.getY(0);
          
	       }
	       if (me.getAction() == MotionEvent.ACTION_UP) {
	       }	
	       try {
	           Thread.sleep(15);
	       } catch (Exception e) {
	       }
	}
			
	@SuppressWarnings("unused")
	private void objSerializer(int resourceId, String outputName){ //example Resource ID --> R.raw.myShape_Obj
		ObjParser objParser = new ObjParser(mContext.getResources(), mTextureManager, resourceId);
		objParser.parse();
		BaseObject3D serializer = objParser.getParsedObject();
		MeshExporter exporter = new MeshExporter(serializer);
		exporter.export(outputName, ExportType.SERIALIZED);	
	}
}